# -*- coding: utf-8 -*-
"""Image classification_MedMNIST.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uZJxseZ9o_kK0vkDqiU9Xi0hYA_TWIkD

"""

#Loading all the libraries
import medmnist #loads dataset.
import numpy as np#for numerical operations
import pandas as pd# for data analysis
import matplotlib.pyplot as plt# for visuals
import seaborn as sns#for statistics plots
import tensorflow as tf# for image in multidimensional arrays
import cv2

from medmnist import BreastMNIST
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.optimizers import Adam
from tensorflow import keras
from tensorflow.keras import layers
from PIL import Image# for image files
import streamlit as st

# Here I am loading the Breast Cancer dataset from MedMNIST
train_data = BreastMNIST(split='train', download=True)
val_data = BreastMNIST(split='val', download=True)
test_data = BreastMNIST(split='test', download=True)



# Extract images and labels
X_train, y_train = train_data.imgs, train_data.labels
X_val, y_val = val_data.imgs, val_data.labels
X_test, y_test = test_data.imgs, test_data.labels

# Print dataset shapes
print("Training set shape:", X_train.shape, "Train Labels shape:", y_train.shape)
print("Validation set shape:", X_val.shape, "Validation Labels shape:", y_val.shape)
print("Testing set shape:", X_test.shape, "Testing Labels shape:", y_test.shape)

# Here Im changing all the labels from 2d array to 1D array using squeeze function
y_train = y_train.squeeze()
y_val = y_val.squeeze()
y_test = y_test.squeeze()

#Viewing the shape of the labels in the dataset
print("Training set labels shape:", y_train.shape)
print("Validation set labels shape:", y_val.shape)
print("Testing set labels shape:", y_test.shape)

# Checking here the shape of some image in the training set
print("Shape of the first image:", X_train[0].shape)
print("Shape of the 255th image:", X_train[254].shape)
print("Shape of the 546th image:", X_train[545].shape)

# Viewing the first image from train set
plt.imshow(X_train[0], cmap='gray')
plt.title("First Image")
plt.show()

# Viewing the first image from test set
plt.imshow(X_test[0], cmap='gray')
plt.title("First Image")
plt.show()

# Viewing the first image from val set
plt.imshow(X_val[0], cmap='gray')
plt.title("First Image")
plt.show()

# Viewing the first image in grayscale, without the axis labels
plt.imshow(X_train[0], cmap='gray')
plt.title("First Image")
plt.axis('off')
plt.show()

# Viewing here the first 5 images in the training set
figure, axes = plt.subplots(1, 5, figsize=(15, 6))
for i, ax in enumerate(axes):
    ax.imshow(X_train[i], cmap='gray')
    ax.set_title(f'Label: {y_train[i]}')
    ax.axis('off')

plt.show()

# Viewing here the first 2 rows images in the training set
figure, axes = plt.subplots(2, 5, figsize=(15, 6))
for i, ax in enumerate(axes.flatten()):
    ax.imshow(X_train[i], cmap='gray')
    ax.set_title(f'Label: {y_train[i]}')
    ax.axis('off')

plt.show()

# Viewing for the last 10 images in the training set
figure, axes = plt.subplots(2, 5, figsize=(15, 6))
for i, ax in enumerate(axes.flatten()):
    ax.imshow(X_train[-10 + i], cmap='gray')
    ax.set_title(f'Label: {y_train[-10 + i]}')
    ax.axis('off')

plt.show()

benign_images = X_train[y_train == 0]
malignant_images = X_train[y_train == 1]

# Viewing first 5 benign images
fig, axes = plt.subplots(1, 5, figsize=(15, 5))
for i, ax in enumerate(axes):
    ax.imshow(benign_images[i], cmap='gray')
    ax.set_title('Benign')
    ax.axis('off')
plt.show()

# Viewing the first 5 malignant images
fig, axes = plt.subplots(1, 5, figsize=(15, 5))
for i, ax in enumerate(axes):
    ax.imshow(malignant_images[i], cmap='gray')
    ax.set_title('Malignant')
    ax.axis('off')
plt.show()

#Checking for any duplicate images
def count_duplicates(images):
    reshaped_images = images.reshape(images.shape[0], -1)
    return pd.DataFrame(reshaped_images).duplicated().sum()
#???
print(f" Duplicate images in Training Set: {count_duplicates(X_train)}")
print(f" Duplicate images in Validation Set: {count_duplicates(X_val)}")
print(f" Duplicate images in Testing Set: {count_duplicates(X_test)}")

#source:https://stackoverflow.com/questions/60876805/how-to-show-the-class-distribution-in-dataset-object-in-tensorflow

# Function to count class distribution in a dataset
def count_classes(labels):
    return dict(zip(*np.unique(labels, return_counts=True)))

print('  Benign = 0     Malignant = 1')
print('')
print(f" Class count in Training Set:\n {count_classes(y_train)}")
print(f" Class count in Validation Set:\n {count_classes(y_val)}")
print(f" Class count in Testing Set:\n {count_classes(y_test)}")

# Bar chart to check class balance
sns.countplot(x=y_train)
plt.title(" Class count in Training Set")
plt.xticks([0, 1], ['Benign ', 'Malignant'])
plt.show()

# Bar chart to check class balance
sns.countplot(x=y_test)
plt.title(" Class count in Testing Set")
plt.xticks([0, 1], ['Benign ', 'Malignant'])
plt.show()

# Bar chart to check class balance
sns.countplot(x=y_val)
plt.title(" Class count in Validation Set")
plt.xticks([0, 1], [' Benign', 'Malignant '])
plt.show()


# Reshaping the dataset for the model
X_train = X_train.reshape(-1, 28, 28, 1).astype('float32') / 255.0
X_test = X_test.reshape(-1, 28, 28, 1).astype('float32') / 255.0

# Neural Network Model
def nn_model():
    model = keras.Sequential([
        layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)), # this will extract features
        layers.MaxPooling2D((2, 2)), #reduces dimension
        layers.Conv2D(64, (3, 3), activation='relu'), #deeper feature extractions
        layers.MaxPooling2D((2, 2)),
        layers.Flatten(),# converts feature maps to 1D
        layers.Dense(64, activation='relu'),#fully connected layer
        layers.Dense(1, activation='sigmoid')#outputs probability of tumour being malignant
    ])
    model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return model

model = nn_model()
model.fit(X_train, y_train, epochs=3, batch_size=32, validation_data=(X_test, y_test))

# Flattening images for SVM and Logistic Regression
#Here it converts each image into a 1D vector for compatability
X_train_flat = X_train.reshape(X_train.shape[0], -1)
X_test_flat = X_test.reshape(X_test.shape[0], -1)



#This for Support Vector Machine (SVM)
svm_model = SVC(kernel='sigmoid')
svm_model.fit(X_train_flat, y_train)
svm_predictions = svm_model.predict(X_test_flat)
svm_accuracy = accuracy_score(y_test, svm_predictions)



# This is for Logistic Regression
log_reg_model = LogisticRegression()
log_reg_model.fit(X_train_flat, y_train)
log_reg_predictions = log_reg_model.predict(X_test_flat)
log_reg_accuracy = accuracy_score(y_test, log_reg_predictions)



# Plotting the confusion matrices
def plot_cm(y_true, y_pred, title):
    cm = confusion_matrix(y_true, y_pred)
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
    plt.title(title)
    plt.xlabel('Predicted')
    plt.ylabel('True')
    plt.show()

# Plot confusion matrices
plot_cm(y_test, model.predict(X_test).round(), " Neural Network Confusion Matrix")
plot_cm(y_test, svm_predictions, " SVM Confusion Matrix")
plot_cm(y_test, log_reg_predictions, " Logistic Regression Confusion Matrix")

# Print classification reports
print(" Neural Network Classification Report:")
print(classification_report(y_test, model.predict(X_test).round()))

print(" SVM Classification Report:")
print(classification_report(y_test, svm_predictions))

print(" Logistic Regression Classification Report:")
print(classification_report(y_test, log_reg_predictions))



# Creating Streamlit user interface
st.title(" Breast Cancer Tumor Classifier")
st.write(" Upload an ultrasound image to predict if the tumor is malignant or benign.")

# Upload image
uploaded_image = st.file_uploader(" Please input your medical image", type=["jpg", "jpeg", "png"])

#Image pre-processing
if uploaded_image is not None:
    image = Image.open(uploaded_image)
    image = image.convert('L')  # Convert to grayscale
    image = np.array(image)
    image = cv2.resize(image, (28, 28))  # Resize to match model input
    image = image.reshape(1, 28, 28, 1).astype('float32') / 255.0

# Predict with the model
    prediction = model.predict(image)
    result = " Malignant" if prediction > 0.5 else " Benign"

 # Display the result
    st.image(uploaded_image, caption=" Image uploaded ", use_container_width=True)
    st.write(f"Prediction: {result}")